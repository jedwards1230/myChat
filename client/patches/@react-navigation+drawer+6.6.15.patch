diff --git a/node_modules/@react-navigation/drawer/lib/module/views/modern/Drawer.js b/node_modules/@react-navigation/drawer/lib/module/views/modern/Drawer.js
index 1fdb8a2..012ac45 100644
--- a/node_modules/@react-navigation/drawer/lib/module/views/modern/Drawer.js
+++ b/node_modules/@react-navigation/drawer/lib/module/views/modern/Drawer.js
@@ -222,17 +222,43 @@ export default function Drawer(_ref) {
     };
   });
   const contentAnimatedStyle = useAnimatedStyle(() => {
-    return {
-      transform: drawerType === 'permanent' ?
-      // Reanimated needs the property to be present, but it results in Browser bug
-      // https://bugs.chromium.org/p/chromium/issues/detail?id=20574
-      [] : [{
-        translateX:
-        // The screen content stays in place when `drawerType` is `front`
-        drawerType === 'front' ? 0 : translateX.value + drawerWidth * (drawerPosition === 'left' ? 1 : -1)
-      }]
-    };
-  });
+    if (Platform.OS === 'web') {
+      // For web, adjust the width instead of using translateX
+      return {
+        /* transform: [
+          {
+            translateX:
+              drawerType === 'front'
+                ? 0
+                : translateX.value +
+                  drawerWidth * (drawerPosition === 'left' ? 1 : -1),
+          },
+        ],
+        width: '100%', */
+        // the left side change is an absolute element, so we need to adjust the width and push it from the left side to accomodate the new elemeent
+        width: `calc(100% - ${drawerWidth}px)`,
+        //left: drawerType === 'permanent' ? 0 : translateX.value + drawerWidth * (drawerPosition === 'left' ? 1 : -1),
+        // maybe margin left instead
+        marginLeft: drawerType === 'permanent' ? 0 : translateX.value + drawerWidth * (drawerPosition === 'left' ? 1 : -1),
+      };
+    } else {
+      // For other platforms, keep the original logic
+      return {
+        transform:
+          drawerType === 'permanent'
+            ? []
+            : [
+                {
+                  translateX:
+                    drawerType === 'front'
+                      ? 0
+                      : translateX.value +
+                        drawerWidth * (drawerPosition === 'left' ? 1 : -1),
+                },
+              ],
+      };
+    }
+  })
   const progress = useDerivedValue(() => {
     return drawerType === 'permanent' ? 1 : interpolate(translateX.value, [getDrawerTranslationX(false), getDrawerTranslationX(true)], [0, 1]);
   });
@@ -254,7 +280,7 @@ export default function Drawer(_ref) {
     accessibilityElementsHidden: isOpen && drawerType !== 'permanent',
     importantForAccessibility: isOpen && drawerType !== 'permanent' ? 'no-hide-descendants' : 'auto',
     style: styles.content
-  }, renderSceneContent()), drawerType !== 'permanent' ? /*#__PURE__*/React.createElement(Overlay, {
+  }, renderSceneContent()), (drawerType !== 'permanent' && Platform.OS !== "web") ? /*#__PURE__*/React.createElement(Overlay, {
     progress: progress,
     onPress: () => toggleDrawer({
       open: false,
@@ -265,7 +291,7 @@ export default function Drawer(_ref) {
   }) : null), /*#__PURE__*/React.createElement(Animated.View, {
     removeClippedSubviews: Platform.OS !== 'ios',
     style: [styles.container, {
-      position: drawerType === 'permanent' ? 'relative' : 'absolute',
+      position: drawerType === 'permanent' ? 'absolute' : 'absolute',
       zIndex: drawerType === 'back' ? -1 : 0
     }, drawerAnimatedStyle, drawerStyle]
   }, renderDrawerContent()))));
